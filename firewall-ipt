#!/usr/bin/env bash
set -euo pipefail

# Simple interactive iptables rule builder/applier.
# Works with iptables classic (requires root).

# Colors
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
CYAN="\033[1;36m"
RESET="\033[0m"

IPT=(iptables)
if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
  echo "Note: iptables requires root. I will use sudo to run commands." >&2
  IPT=(sudo iptables)
fi

prompt() {
  local label="$1" default="${2-}"
  local input
  if [[ -n "$default" ]]; then
    read -r -p "$label [$default]: " input
    echo "${input:-$default}"
  else
    read -r -p "$label: " input
    echo "$input"
  fi
}

print_cmd() {
  echo -e "${YELLOW}Command to run:${RESET}"
  printf '>> '
  printf '%q ' "$@"
  echo ""
}

run_cmd() {
  print_cmd "$@"
  "$@"
}

is_valid_port() {
  local p="$1"
  if [[ "$p" =~ ^[0-9]+$ ]]; then
    [[ "$p" -ge 1 && "$p" -le 65535 ]]
  elif [[ "$p" =~ ^[0-9]+:[0-9]+$ ]]; then
    local a b
    a="${p%%:*}"
    b="${p##*:}"
    [[ "$a" -ge 1 && "$a" -le 65535 && "$b" -ge 1 && "$b" -le 65535 && "$a" -le "$b" ]]
  else
    return 1
  fi
}

is_valid_ports_spec() {
  local spec="$1"
  local token
  local count=0

  [[ -n "$spec" ]] || return 1

  IFS=',' read -r -a tokens <<< "$spec"
  for token in "${tokens[@]}"; do
    token="${token//[[:space:]]/}"
    [[ -n "$token" ]] || return 1
    is_valid_port "$token" || return 1
    count=$((count + 1))
  done

  # iptables multiport supports up to 15 ports/ranges per rule.
  [[ "$count" -le 15 ]]
}

choose_action() {
  echo -e "${CYAN}Action:${RESET}" >&2
  echo -e "  ${GREEN}1${RESET}) Allow (ACCEPT)" >&2
  echo -e "  ${RED}2${RESET}) Block (DROP)" >&2
  local choice
  while true; do
    choice=$(prompt "Action (1-2) 1=Allow, 2=Block" "1")
    case "$choice" in
      1) echo "ACCEPT"; return 0 ;;
      2) echo "DROP"; return 0 ;;
      *) echo "Invalid option." ;;
    esac
  done
}

choose_chain() {
  echo -e "${CYAN}Direction:${RESET}" >&2
  echo -e "  ${GREEN}1${RESET}) Incoming (INPUT)" >&2
  echo -e "  ${GREEN}2${RESET}) Outgoing (OUTPUT)" >&2
  echo -e "  ${GREEN}3${RESET}) Forwarding (FORWARD)" >&2
  local choice
  while true; do
    choice=$(prompt "Direction (1-3) 1=Incoming, 2=Outgoing, 3=Forwarding" "1")
    case "$choice" in
      1) echo "INPUT"; return 0 ;;
      2) echo "OUTPUT"; return 0 ;;
      3) echo "FORWARD"; return 0 ;;
      *) echo "Invalid option." ;;
    esac
  done
}

choose_proto() {
  echo -e "${CYAN}Protocol:${RESET}" >&2
  echo -e "  ${GREEN}1${RESET}) tcp" >&2
  echo -e "  ${GREEN}2${RESET}) udp" >&2
  echo -e "  ${GREEN}3${RESET}) icmp" >&2
  echo -e "  ${GREEN}4${RESET}) all (without -p)" >&2
  local choice
  while true; do
    choice=$(prompt "Protocol (1-4) 1=tcp, 2=udp, 3=icmp, 4=all" "1")
    case "$choice" in
      1) echo "tcp"; return 0 ;;
      2) echo "udp"; return 0 ;;
      3) echo "icmp"; return 0 ;;
      4) echo "all"; return 0 ;;
      *) echo "Invalid option." ;;
    esac
  done
}

apply_rule() {
  local action chain proto port src dst inif outif

  action=$(choose_action)
  chain=$(choose_chain)
  proto=$(choose_proto)

  port=""
  if [[ "$proto" == "tcp" || "$proto" == "udp" ]]; then
    while true; do
      port=$(prompt "Port(s)/range(s) (e.g.: 80, 22,1234,12411 or 1000:2000, or 'any')" "any")
      if [[ "$port" == "any" ]]; then
        port=""
        break
      fi
      if is_valid_ports_spec "$port"; then
        port="${port//[[:space:]]/}"
        break
      fi
      echo "Invalid port(s). Use commas for multiple values, max 15 items."
    done
  fi

  src=$(prompt "Source IP/CIDR (enter to skip)" "")
  dst=$(prompt "Destination IP/CIDR (enter to skip)" "")

  inif=""
  outif=""
  if [[ "$chain" == "INPUT" || "$chain" == "FORWARD" ]]; then
    inif=$(prompt "Input interface (enter to skip)" "")
  fi
  if [[ "$chain" == "OUTPUT" || "$chain" == "FORWARD" ]]; then
    outif=$(prompt "Output interface (enter to skip)" "")
  fi

  local -a cmd
  cmd=("${IPT[@]}" -A "$chain")

  if [[ "$proto" != "all" ]]; then
    cmd+=(-p "$proto")
  fi
  if [[ -n "$port" ]]; then
    if [[ "$port" == *,* ]]; then
      cmd+=(-m multiport --dports "$port")
    else
      cmd+=(--dport "$port")
    fi
  fi
  if [[ -n "$src" ]]; then
    cmd+=(-s "$src")
  fi
  if [[ -n "$dst" ]]; then
    cmd+=(-d "$dst")
  fi
  if [[ -n "$inif" ]]; then
    cmd+=(-i "$inif")
  fi
  if [[ -n "$outif" ]]; then
    cmd+=(-o "$outif")
  fi

  cmd+=(-j "$action")

  echo ""
  print_cmd "${cmd[@]}"

  local confirm
  confirm=$(prompt "Apply rule? (y/N)" "N")
  case "$confirm" in
    y|Y|yes|YES|s|S|si|SI)
      "${cmd[@]}"
      echo -e "${GREEN}Rule applied.${RESET}"
      ;;
    *)
      echo -e "${RED}Canceled.${RESET}"
      ;;
  esac
}

main_menu() {
  while true; do
    echo ""
    echo -e "${BLUE}Firewall wizard (iptables)${RESET}"
    echo -e "  ${GREEN}1${RESET}) Create and apply rule"
    echo -e "  ${GREEN}2${RESET}) List current rules"
    echo -e "  ${GREEN}3${RESET}) Enable firewall (default DROP)"
    echo -e "  ${GREEN}4${RESET}) Disable firewall (default ACCEPT)"
    echo -e "  ${GREEN}5${RESET}) Aggressive mode (OUTPUT DROP + allowlist)"
    echo -e "  ${GREEN}6${RESET}) Internet mode (DNS + HTTP/HTTPS)"
    echo -e "  ${GREEN}7${RESET}) Delete rule by number"
    echo -e "  ${RED}8${RESET}) Exit"
    local choice
    choice=$(prompt "Menu (1-8) 1=Create, 2=List, 3=Enable, 4=Disable, 5=Aggressive, 6=Internet, 7=Delete, 8=Exit" "1")
    case "$choice" in
      1) apply_rule ;;
      2) run_cmd "${IPT[@]}" -L -n -v --line-numbers ;;
      3) enable_firewall ;;
      4) disable_firewall ;;
      5) aggressive_mode ;;
      6) internet_mode ;;
      7) delete_rule ;;
      8) exit 0 ;;
      *) echo "Invalid option." ;;
    esac
  done
}

enable_firewall() {
  echo ""
  echo -e "${YELLOW}Enable firewall:${RESET} INPUT=DROP, FORWARD=DROP, OUTPUT=ACCEPT"
  local confirm
  confirm=$(prompt "Confirm? (y/N)" "N")
  case "$confirm" in
    y|Y|yes|YES|s|S|si|SI)
      # Safe baseline rules.
      run_cmd "${IPT[@]}" -C INPUT -i lo -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I INPUT -i lo -j ACCEPT
      run_cmd "${IPT[@]}" -C INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      run_cmd "${IPT[@]}" -C FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

      run_cmd "${IPT[@]}" -P INPUT DROP
      run_cmd "${IPT[@]}" -P FORWARD DROP
      run_cmd "${IPT[@]}" -P OUTPUT ACCEPT
      echo -e "${GREEN}Firewall enabled.${RESET}"
      ;;
    *) echo -e "${RED}Canceled.${RESET}" ;;
  esac
}

disable_firewall() {
  echo ""
  echo -e "${YELLOW}Disable firewall:${RESET} INPUT=ACCEPT, FORWARD=ACCEPT, OUTPUT=ACCEPT"
  local confirm
  confirm=$(prompt "Confirm? (y/N)" "N")
  case "$confirm" in
    y|Y|yes|YES|s|S|si|SI)
      run_cmd "${IPT[@]}" -P INPUT ACCEPT
      run_cmd "${IPT[@]}" -P FORWARD ACCEPT
      run_cmd "${IPT[@]}" -P OUTPUT ACCEPT
      echo -e "${GREEN}Firewall disabled (policies set to ACCEPT).${RESET}"
      ;;
    *) echo -e "${RED}Canceled.${RESET}" ;;
  esac
}

aggressive_mode() {
  echo ""
  echo -e "${YELLOW}Aggressive mode:${RESET} INPUT=DROP, FORWARD=DROP, OUTPUT=DROP"
  echo -e "${YELLOW}Only outbound traffic explicitly allowed in OUTPUT rules will pass.${RESET}"
  local confirm
  confirm=$(prompt "Confirm aggressive mode? (y/N)" "N")
  case "$confirm" in
    y|Y|yes|YES|s|S|si|SI)
      # Baseline rules to keep loopback and established/related traffic working.
      run_cmd "${IPT[@]}" -C INPUT -i lo -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I INPUT -i lo -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -o lo -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I OUTPUT -o lo -j ACCEPT
      run_cmd "${IPT[@]}" -C INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      run_cmd "${IPT[@]}" -C FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

      run_cmd "${IPT[@]}" -P INPUT DROP
      run_cmd "${IPT[@]}" -P FORWARD DROP
      run_cmd "${IPT[@]}" -P OUTPUT DROP
      echo -e "${GREEN}Aggressive mode enabled.${RESET}"
      ;;
    *) echo -e "${RED}Canceled.${RESET}" ;;
  esac
}

internet_mode() {
  echo ""
  echo -e "${YELLOW}Internet mode:${RESET} INPUT=DROP, FORWARD=DROP, OUTPUT=DROP + web allowlist"
  echo -e "${YELLOW}Allows DNS (53 tcp/udp), HTTP (80/tcp), HTTPS (443/tcp+udp).${RESET}"
  local confirm
  confirm=$(prompt "Confirm internet mode? (y/N)" "N")
  case "$confirm" in
    y|Y|yes|YES|s|S|si|SI)
      # Safe baseline: loopback and established/related traffic.
      run_cmd "${IPT[@]}" -C INPUT -i lo -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I INPUT -i lo -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -o lo -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I OUTPUT -o lo -j ACCEPT
      run_cmd "${IPT[@]}" -C INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      run_cmd "${IPT[@]}" -C FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -I FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

      # Outbound internet allowlist.
      run_cmd "${IPT[@]}" -C OUTPUT -p udp --dport 53 -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -A OUTPUT -p udp --dport 53 -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -p tcp --dport 53 -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -A OUTPUT -p tcp --dport 53 -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -A OUTPUT -p tcp --dport 80 -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -A OUTPUT -p tcp --dport 443 -j ACCEPT
      run_cmd "${IPT[@]}" -C OUTPUT -p udp --dport 443 -j ACCEPT 2>/dev/null || run_cmd "${IPT[@]}" -A OUTPUT -p udp --dport 443 -j ACCEPT

      run_cmd "${IPT[@]}" -P INPUT DROP
      run_cmd "${IPT[@]}" -P FORWARD DROP
      run_cmd "${IPT[@]}" -P OUTPUT DROP
      echo -e "${GREEN}Internet mode enabled.${RESET}"
      ;;
    *) echo -e "${RED}Canceled.${RESET}" ;;
  esac
}

delete_rule() {
  echo ""
  echo -e "${YELLOW}Delete rule by number${RESET}"
  local chain rule_num confirm

  chain=$(choose_chain)

  echo ""
  echo -e "${CYAN}Current rules in ${chain}:${RESET}"
  run_cmd "${IPT[@]}" -L "$chain" -n -v --line-numbers

  while true; do
    rule_num=$(prompt "Rule number to delete in ${chain} (enter to cancel)" "")
    if [[ -z "$rule_num" ]]; then
      echo -e "${RED}Canceled.${RESET}"
      return 0
    fi
    if [[ "$rule_num" =~ ^[0-9]+$ ]] && [[ "$rule_num" -ge 1 ]]; then
      break
    fi
    echo "Invalid number."
  done

  confirm=$(prompt "Confirm deletion of ${chain} line ${rule_num}? (y/N)" "N")
  case "$confirm" in
    y|Y|yes|YES|s|S|si|SI)
      run_cmd "${IPT[@]}" -D "$chain" "$rule_num"
      echo -e "${GREEN}Rule deleted.${RESET}"
      ;;
    *)
      echo -e "${RED}Canceled.${RESET}"
      ;;
  esac
}

main_menu
